---
title: "R Notebook: Stringmatch"
output: html_notebook
---


# Load data files
```{r}
library(dplyr)

# specify the directory where the files are located
# For NOAA machines
# dir_path <- "/Users/enrique.montes/Google Drive/My Drive/GDrive/OCED_AOML/WS_cruises/plankton_imaging/CPICS/TS.Master_selection"
# For personal machine
dir_path <- "~/Library/CloudStorage/GoogleDrive-enriquemontes01@gmail.com/My Drive/GDrive/OCED_AOML/WS_cruises/plankton_imaging/CPICS/TS.Master_selection"

# obtain a list of file names in the directory
file_names <- list.files(path = dir_path, pattern = ".txt", full.names = TRUE)

# loop over each file and import the tables (use this for DATES)
for (file in file_names) {
  table_name <- gsub(".txt", "", basename(file)) # get the name of the table from the file name
  assign(table_name, read.table(file = file, header = FALSE, sep = "\t") %>%
           mutate(date = as.POSIXct(substr(V1, start = 24, stop = 36), format="%Y%m%d_%H%M", tz="UTC")))
}

# # loop over each file and import the tables (use this for STRINGS)
# for (file in file_names) {
#   table_name <- gsub(".txt", "", basename(file)) # get the name of the table from the file name
#   assign(table_name, read.table(file = file, header = FALSE, sep = "\t"))
# }

```


# Match file name using DATE values (not string matching) 
```{r}
library(tidyverse)
library(lubridate)

# Directory where the CTD metadata is located
# For NOAA machines
# dir_path2 <- "/Users/enrique.montes/Library/CloudStorage/GoogleDrive-enriquemontes01@gmail.com/My Drive/GDrive/OCED_AOML/WS_cruises/plankton_imaging/CPICS/ws_cruise_ctd"
# For personal machine
dir_path2 <- "~/Library/CloudStorage/GoogleDrive-enriquemontes01@gmail.com/My Drive/GDrive/OCED_AOML/WS_cruises/plankton_imaging/CPICS/ws_cruise_ctd"

file_name <- list.files(path = dir_path2, pattern = "ctd_meta_v3.csv", full.names = TRUE)
ctd_meta <- read.csv(file_name, fill = TRUE)

# # USE WITH ctd_meta_v2.csv
# dt_list <- ctd_meta$GMT.datetime %>% as.POSIXct(unique_all, format="%Y%m%d_%H%M", tz="UTC")

# # USE WITH ctd_meta_v3.csv
dt_list <- as.POSIXct(paste(ctd_meta$year,
                                         sprintf("%02d", ctd_meta$month),
                                         sprintf("%02d", ctd_meta$day),
                                         ctd_meta$time_gmt),
                                   format = "%Y%m%d %I:%M:%S %p",
                                   tz = "UTC")
            
# Create empty data frame to store results
conc_occ_final <- data.frame(date = character(), count = numeric())

# time before and after CTD time in seconds so that CPICS records are matched to CTD times centered around start and stop intervals.
start <- 5 * 60 
stop <- 20 * 60 

# Iterate over dt_list intervals.
for (i in 1:(length(dt_list))) {
  
  # Subset A for dates within current interval
  acantha_subset <- subset(class.Acantharea, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    acantha_count <- nrow(acantha_subset)
  centric_subset <- subset(class.Centric, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    centric_count <- nrow(centric_subset)
  ceratium_subset <- subset(class.Ceratium, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    ceratium_count <- nrow(ceratium_subset)
  chaetoceros_subset <- subset(class.Chaetoceros, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    chaetoceros_count <- nrow(chaetoceros_subset)
  chaetog_subset <- subset(class.Chaetognaths, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    chaetog_count <- nrow(chaetog_subset)
  chain1_subset <- subset(class.Chain2, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    chain1_count <- nrow(chain1_subset)
  chain2_subset <- subset(class.Chain3, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    chain2_count <- nrow(chain2_subset)
  # chain3_subset <- subset(class.Chain4, date >= dt_list[i]-start & date < dt_list[i]+stop) 
  #   chain3_count <- nrow(chain3_subset)
  clado_subset <- subset(class.Cladocera, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    clado_count <- nrow(clado_subset)
  copepod_subset <- subset(class.Copepods, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    copepod_count <- nrow(copepod_subset)
  deca_subset <- subset(class.Decapods, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    deca_count <- nrow(deca_subset)
  echino_subset <- subset(class.Echinoderms, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    echino_count <- nrow(echino_subset)
  gui_subset <- subset(class.Guinardia, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    gui_count <- nrow(gui_subset)
  jel_subset <- subset(class.Jellies, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    jel_count <- nrow(jel_subset)
  larv_subset <- subset(class.Larvaceans, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    larv_count <- nrow(larv_subset)
  neocal_subset <- subset(class.Neocalyptrella, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    neocal_count <- nrow(neocal_subset)
  nocti_subset <- subset(class.Noctiluca, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    nocti_count <- nrow(nocti_subset)
  poly_subset <- subset(class.Polychaets, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    poly_count <- nrow(poly_subset)
  ptero_subset <- subset(class.Pteropods, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    ptero_count <- nrow(ptero_subset)  
  tricho_subset <- subset(class.Tricho, date >= dt_list[i]-start & date < dt_list[i]+stop) 
    tricho_count <- nrow(tricho_subset)
    
  # Add date and count to results data frame
  result <- data.frame(date = dt_list[i], 
                       Acantharea = acantha_count,
                       Centric_diatoms = centric_count,
                       Ceratium = ceratium_count,
                       Chaetoceros = chaetoceros_count,
                       Chaetognaths = chaetog_count,
                       Diatoms = chain1_count,
                       Diatoms2 = chain2_count,
                       # Diatom_chains_3 = chain3_count,
                       Cladocera = clado_count,
                       Copepods = copepod_count,
                       Decapods = deca_count,
                       Echinoderms = echino_count,
                       Guinardia = gui_count,
                       Jellies = jel_count,
                       Larvaceans = larv_count,
                       Neocalyptrella = neocal_count,
                       Noctiluca_sp = nocti_count,
                       Polychaetes = poly_count,
                       Pteropods = ptero_count,
                       Trichodesmium = tricho_count)
                       
  conc_occ_final <- do.call(rbind, list(conc_occ_final, result))
} 

taxa_meta <- cbind(ctd_meta, conc_occ_final)

```


# # Calculate plankton concentrations
```{r}
spp_df <- taxa_meta[ , c("X8.day.seascapes", "total_vol_sampled", "date",
                              "Acantharea",
                              "Copepods",
                              "Echinoderms",
                              "Jellies",
                              "Larvaceans",
                              "Polychaetes",
                              "Chaetognaths",
                              "Pteropods")]
 
spp_df_long <- gather(spp_df, key = "Species", value = "Frequency", -total_vol_sampled) # , -X8.day.seascapes

# calculate relative frequencies
concentration_df <- spp_df_long %>%
  group_by(X8.day.seascapes, Species) %>%
  summarise(n = sum(Frequency)) %>%
  mutate(freq = n / sum(n))

```


# Generate plots 
```{r}
library(tidyverse)
library(hrbrthemes)
library(viridis)

# # Load seascape color palette used with Matlab and extract RGB values for observed unique seascapes
# For NOAA machines
# palette_dir <- "/Users/enrique.montes/Library/CloudStorage/GoogleDrive-enriquemontes01@gmail.com/My Drive/GDrive/software/matlab/m_map/seascape_cm"
# For personal machine
palette_dir <- "~/Library/CloudStorage/GoogleDrive-enriquemontes01@gmail.com/My Drive/GDrive/software/matlab/m_map/seascape_cm"
palette_file <- list.files(path = palette_dir, pattern = "cmap1.csv", full.names = TRUE)
palette_df <- read.csv(palette_file, header = FALSE)
colnames(palette_df) <- c("r", "g", "b")
unique_seascapes <- sort(unique(na.omit(ctd_meta$X8.day.seascapes)))
subset_palette_df <- palette_df[unique_seascapes, ]

# set RGB values for the plots
r_vals <- round(subset_palette_df$r * 255, 0)
g_vals <- round(subset_palette_df$g * 255, 0)
b_vals <- round(subset_palette_df$b * 255, 0)
custom_pal <- cbind(r_vals, g_vals, b_vals)
custom_pal_hex <- rgb(custom_pal[, 1], custom_pal[, 2], custom_pal[, 3], maxColorValue=255)
# pal_final <- c(custom_pal_hex[3], custom_pal_hex[4], custom_pal_hex[5], )

# filter out rows with NA values in column seascapes
df_filtered <- taxa_meta[complete.cases(taxa_meta$X8.day.seascapes),]

# Convert the 'x' column to character
df_filtered$X8.day.seascapes <- as.character(df_filtered$X8.day.seascapes)

# Variables
# Avg.chl.a..ug.L.
# salinity
# NH4...uM.
# NO3.NO2..uM.
# PO4...uM.
# DO..mg.L.
# temp..degC.

# # Reorder seascape categories in X axis
df_filtered$X8.day.seascapes <- factor(df_filtered$X8.day.seascapes, levels = c("3", "5", "7", "11", "13", "15","21","27"))

# Define custom colors for each level
custom_colors <- c("3" = custom_pal_hex[1], "5" = custom_pal_hex[2], "7" = custom_pal_hex[3],
                   "11" = custom_pal_hex[4], "13" = custom_pal_hex[5], "15" = custom_pal_hex[6],
                   "21" = custom_pal_hex[7], "27" = custom_pal_hex[8])

# Filter out seascape class as desired
df_filtered <- df_filtered[df_filtered$X8.day.seascapes != "5", ]

# Plot
# See https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html for color palette options
pp <- df_filtered %>%
  ggplot( aes(x=X8.day.seascapes, y=PO4...uM., fill=X8.day.seascapes)) +
    geom_boxplot() +
    # scale_fill_viridis(option="H", discrete = TRUE, alpha=0.6) +
    scale_fill_manual(values = custom_colors) +
    geom_jitter(color="black", size=0.8, alpha=0.9) +
    labs(x = "Seascape class") +
    # labs(y = expression("[Chl-a] (mg/L)")) +
    # labs(y = expression("Salinity")) +
    # labs(y = expression(paste("Temperature (", degree, "C) at 1 m depth"))) +
    # labs(y = expression("DO (mg/L)")) +
    # labs(y = expression("NO"["x"] ~ mu*"M")) +
    labs(y = expression("PO"["4"]^"3-" ~ mu*"M")) +
    # theme(axis.title.y = element_text(hjust = 1))
    # scale_x_discrete(labels= c("Tropical/Subtropical Upwelling", 
    #                          "Tropical Seas", 
    #                          "Warm, Blooms, High Nuts", 
    #                          "Tropical/Subtropical Transition", 
    #                          "Temperate Transition")) +
    theme_ipsum() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    # ggtitle("A boxplot with jitter") +
    # theme(axis.text.x = element_text(angle = 45)) +
  # ylim(15, 28) +  
  theme(axis.text.x = element_text(size = 32),  # Set X-axis label font size
          axis.text.y = element_text(size = 32)) +
    theme(axis.title.x = element_text(size = 18),
          axis.title.y = element_text(size = 18)) +
    theme(legend.text = element_text(size = 32)) 
pp
```

# Create stackplots showing relative frequency of plankton taxa per seascape category
```{r}
# convert abundance columns to relative frequency

# subsets taxa for zooplankton
df_subset <- df_filtered[ , c("X8.day.seascapes",
                              "Acantharea",
                              "Copepods",
                              "Echinoderms",
                              "Jellies",
                              "Larvaceans",
                              "Polychaetes",
                              "Chaetognaths",
                              "Pteropods")]

# subsets taxa for phytoplankton
# df_subset <- df_filtered[ , c("X8.day.seascapes",
#                             "Ceratium",
#                             "Chaetoceros",
#                             "Diatoms",
#                             "Diatoms2",
#                             "Guinardia",
#                             "Neocalyptrella",
#                             "Trichodesmium")]

# subsets taxa for all species
# df_subset <- df_filtered[ , c("X8.day.seascapes",
#                             "Ceratium",
#                             "Chaetoceros",
#                             "Diatoms",
#                             "Diatoms2",
#                             "Guinardia",
#                             "Neocalyptrella",
#                             "Trichodesmium",
#                             "Acantharea",
#                             "Copepods",
#                             "Echinoderms",
#                             "Jellies",
#                             "Larvaceans",
#                             "Polychaetes",
#                             "Chaetognaths",
#                             "Pteropods")]

# reshape the data to long format 
df_long <- tidyr::gather(df_subset, key = "Species", value = "Frequency", -X8.day.seascapes)

# calculate relative frequencies
df_sum <- df_long %>%
  group_by(X8.day.seascapes, Species) %>%
  summarise(n = sum(Frequency)) %>%
  mutate(freq = n / sum(n))

# Seascape class names:
# "Class 11" - Tropical/Subtropical Upwelling
# "Class 15" - Tropical Seas
# "Class 21" - Warm, Blooms, High Nuts
# "Class 3" - Tropical/Subtropical Transition
# "Class 7" - Temperate Transition

# # Select desired seascapes and reorder categories in X axis
df_sum$X8.day.seascapes <- factor(df_sum$X8.day.seascapes, levels = c("3", "5", "7", "11", "13", "15","21","27"))

# Filter out seascape class as desired
exclude_classes <- c(5, 7, 11)
df_sum <- df_sum[!df_sum$X8.day.seascapes %in% exclude_classes, ]

# Use qualitative palettes: https://colorbrewer2.org/#type=qualitative&scheme=Accent&n=7
custom_pal_hex2 <- c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf')
# custom_pal_hex2 <- c('#1b9e77','#d95f02','#7570b3','#e7298a','#66a61e','#e6ab02','#a6761d')

# create the stackplot
qq <- ggplot(df_sum, aes(x = X8.day.seascapes, y = freq, fill = Species)) +
  # scale_fill_viridis(option="Set3", discrete = TRUE, alpha=0.8) +
  # scale_fill_viridis(discrete = TRUE, alpha=0.8) +
  scale_fill_manual(values = custom_pal_hex2) +
  geom_bar(stat = "identity") +
  labs(x = "Seascape class") +
  labs(y = "Relative frequency") +
  # scale_x_discrete(labels= c("Tropical/Subtropical Upwelling", 
  #                            "Tropical Seas", 
  #                            "Warm, Blooms, High Nuts", 
  #                            "Tropical/Subtropical Transition", 
  #                            "Temperate Transition")) +
  # theme(axis.text.x = element_text(angle = 45)) +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 32),  # Set X-axis label font size
        axis.text.y = element_text(size = 32)) +
  theme(axis.title.x = element_text(size = 32),
        axis.title.y = element_text(size = 32)) +
  theme(legend.text = element_text(size = 20)) 
  #theme(axis.text.x = element_text(hjust = 1))
qq
```


# Compute Shannon Index
```{r}
library(dplyr)
library(vegan)

# Select species for Shannon calculation
df_subset_shannon <- df_filtered[ , c("X8.day.seascapes",
                              "Acantharea",
                              "Copepods",
                              "Echinoderms",
                              "Jellies",
                              "Larvaceans",
                              "Polychaetes",
                              "Chaetognaths",
                              "Pteropods",
                              "Ceratium",
                              "Chaetoceros",
                              "Diatoms",
                              "Diatoms2",
                              "Guinardia",
                              "Neocalyptrella",
                              "Trichodesmium")]

# reshape the data to long format
df_long <- tidyr::gather(df_subset_shannon, key = "Species", value = "Abundance", -X8.day.seascapes)

# Exclude seascapes
exclude_seascapes <- c(5, 7, 11)

# Compute Shannon diversity per seascape class
shannon_df <- df_long %>% 
  group_by(X8.day.seascapes) %>% 
  summarise(shannon = diversity(Abundance, index = "shannon"))

# Filter the data to exclude specified seascapes
shannon_df_filtered <- shannon_df[!shannon_df$X8.day.seascapes %in% exclude_seascapes, ]

# create the bar plot
ff <- ggplot(shannon_df_filtered, aes(x = X8.day.seascapes, y = shannon, fill = X8.day.seascapes)) +
  geom_bar(stat = "identity") +
  # scale_fill_viridis(option="plasma", discrete = TRUE, alpha=0.6) +
  scale_fill_manual(values = custom_colors) +
  xlab("Seascape Class") +
  ylab("Shannon Diversity") +
  # scale_x_discrete(labels= c("Tropical/Subtropical Upwelling", 
  #                            "Tropical Seas", 
  #                            "Warm, Blooms, High Nuts", 
  #                            "Tropical/Subtropical Transition", 
  #                            "Temperate Transition")) +
  # theme(axis.text.x = element_text(angle = 45)) +
  theme(axis.text.x = element_text(size = 32),  # Set X-axis label font size
        axis.text.y = element_text(size = 32)) +
  theme(axis.title.x = element_text(size = 32),
        axis.title.y = element_text(size = 32)) +
  theme(legend.text = element_text(size = 32)) +
  guides(fill = FALSE)
ff

# Subset the data to exclude specified seascapes
filtered_taxa_meta <- taxa_meta[complete.cases(taxa_meta$X8.day.seascapes), ]
filtered_taxa_meta <- filtered_taxa_meta[!filtered_taxa_meta$X8.day.seascapes %in% exclude_seascapes, ]

tt <- ggplot(filtered_taxa_meta, aes(x = factor(X8.day.seascapes), fill = factor(X8.day.seascapes))) +
  geom_bar(color = "black", alpha = 0.7) +
  scale_fill_manual(values = custom_colors) +
  labs(title = "Histogram of 8X.day.seascapes", x = "Seascape Class", y = "Frequency") +
  theme_minimal() +
    theme(axis.text.x = element_text(size = 32),  # Set X-axis label font size
        axis.text.y = element_text(size = 32)) +
  theme(axis.title.x = element_text(size = 32),
        axis.title.y = element_text(size = 32)) +
  theme(legend.text = element_text(size = 32)) +
  guides(fill = FALSE)
tt

# # Counts of species per seascape
df_sum_abund <- df_long %>%
  group_by(X8.day.seascapes, Species) %>%
  summarise(n = sum(Abundance)) 

df_sum_abund_filt <- df_sum_abund[df_sum_abund$Species == "Guinardia",]
# Filter the data to exclude specified seascapes
df_sum_abund_filt2 <- df_sum_abund_filt[!df_sum_abund_filt$X8.day.seascapes %in% exclude_seascapes, ]

dd <- ggplot(df_sum_abund_filt2, aes(x = factor(X8.day.seascapes), y = n, fill = factor(X8.day.seascapes))) +
  geom_bar(color = "black", alpha = 0.7, stat = "identity") +
  # scale_fill_viridis(option = "magma", discrete = TRUE, alpha = 0.8)
  scale_fill_manual(values = custom_colors) +
  theme_minimal() 
dd

# Compute counts of selected species per seascape class normalized by frequency of seascapes
# reshape the data to long format
df_long2 <- tidyr::gather(df_subset_shannon, key = "Species", value = "Abundance", -X8.day.seascapes)

spp_seascape_normalized <- df_long2 %>%
  filter(Species == "Guinardia") %>%
  group_by(X8.day.seascapes) %>%
  summarise(spp_count = sum(Abundance))

# Compute frequencies of each seascape class
seascape_frequencies <- df_long2 %>%
  count(X8.day.seascapes) %>%
  rename(freq = n)

# Merge counts with frequencies
spp_seascape_normalized <- merge(spp_seascape_normalized, seascape_frequencies, by = "X8.day.seascapes")

# Normalize counts by frequency
spp_seascape_normalized$spp_normalized <- (spp_seascape_normalized$spp_count / spp_seascape_normalized$freq) * 1000
spp_seascape_normalized_filt <- spp_seascape_normalized[!spp_seascape_normalized$X8.day.seascapes %in% exclude_seascapes, ]

bb <- ggplot(spp_seascape_normalized_filt, aes(x = factor(X8.day.seascapes), y = spp_normalized, fill = factor(X8.day.seascapes))) +
  geom_bar(color = "black", alpha = 0.7, stat = "identity") +
  scale_fill_manual(values = custom_colors) +
  labs(x = "Seascape Class", y = "Counts / Seascape freq * 1000") +
  theme_minimal() +
    theme(axis.text.x = element_text(size = 32),  # Set X-axis label font size
        axis.text.y = element_text(size = 32)) +
  theme(axis.title.x = element_text(size = 32),
        axis.title.y = element_text(size = 32)) +
  theme(legend.text = element_text(size = 32)) +
  guides(fill = FALSE)
bb

```

# PC plot
```{r}
library(ggalt)

# Perform principal component analysis on the count data

# for hydrography
sel_vars <- c(
  "X8.day.seascapes",
  # "temp..degC.",
  "salinity",
  "Avg.chl.a..ug.L.",
  "PO4...uM.",
  "NO3.NO2..uM.")

# for taxonomy
# sel_vars <- c("X8.day.seascapes",
#               "Acantharea",
#               "Copepods",
#               "Echinoderms",
#               "Jellies",
#               "Larvaceans",
#               "Polychaetes",
#               "Chaetognaths",
#               "Pteropods")

# sel_vars <- c("X8.day.seascapes",
#               "Ceratium",
#               "Chaetoceros",
#               "Diatoms",
#               "Diatoms2",
#               "Guinardia",
#               "Neocalyptrella",
#               "Trichodesmium")

# sel_vars <- c("X8.day.seascapes",
#               "Acantharea",
#               "Copepods",
#               "Echinoderms",
#               "Jellies",
#               "Larvaceans",
#               "Polychaetes",
#               "Chaetognaths",
#               "Pteropods",
#               "Ceratium",
#               "Chaetoceros",
#               "Diatoms",
#               "Diatoms2",
#               "Guinardia",
#               "Neocalyptrella",
#               "Trichodesmium")

# filter out rows with NA values in column seascapes
# df_filtered_pca <- taxa_meta[complete.cases(taxa_meta$X8.day.seascapes), ]
df_filtered_pca <- taxa_meta[complete.cases(taxa_meta[, sel_vars]), ]
exclude_seascapes <- c(5, 7, 11)
filt_df_pca <- df_filtered_pca[!df_filtered_pca$X8.day.seascapes %in%
                                 exclude_seascapes, sel_vars]

# Select numeric columns in filt_df_pca
numeric_cols <- sapply(filt_df_pca, is.numeric)
# Identify numeric columns except the first one
numeric_cols <- 2:ncol(filt_df_pca)

# Transform numeric columns to log scale
filt_df_pca[numeric_cols] <- lapply(filt_df_pca[numeric_cols], function(x) log(x + 1))


# pca <- prcomp(filt_df_pca[, c("salinity", "Avg.chl.a..ug.L.", "PO4...uM.", "NO3.NO2..uM.")], scale. = TRUE)
pca <- prcomp(filt_df_pca[, -1], scale. = TRUE)

# Extract PC1 and PC2 scores for each sampling event
# pc_scores <- data.frame(seascape = df_subset$X8.day.seascapes, # for taxonomic analysis 
pc_scores <- data.frame(seascape = as.character(filt_df_pca$X8.day.seascapes), # for hydrography
                        PC1 = pca$x[, 1], 
                        PC2 = pca$x[, 2])

# Create the plot
pc_scores$seascape <- factor(pc_scores$seascape, levels = c("3", "13", "15", "21", "27"))
bb <- ggplot(pc_scores, aes(x = PC1, y = PC2, color = seascape)) + 
  geom_point() +
  labs(x = "PC1", y = "PC2", color = "Seascape") 

# add circle around cluster of data points
custom_colors_pca <- custom_pal_hex[c(1, 5, 6, 7, 8)]

yy <- ggplot(pc_scores, aes(x = PC1, y = PC2, color = seascape)) + 
  geom_point() +
  stat_ellipse(aes(fill = seascape), level = 0.90, geom = "polygon", alpha = 0.3, color = "black") +
  scale_color_manual(values = custom_colors_pca) +
  scale_fill_manual(values = custom_colors_pca) +
  theme_classic() +
  xlim(-2,2) +
  ylim(-2,2) +
  # xlim(-1,1) +
  # ylim(-1,1) +
  geom_point(size=2) +
  guides(colour = guide_legend(override.aes = list(size=2))) + 
  theme(axis.text.x = element_text(size = 32),  # Set X-axis label font size
        axis.text.y = element_text(size = 32)) +
  theme(axis.title.x = element_text(size = 32),
        axis.title.y = element_text(size = 32)) +
  theme(legend.text = element_text(size = 32))

yy

################################################################################################
# # Create PCA with eigenvectors
# Extract principal component scores
pc_scores2 <- pca$x
# Extract eigenvectors
eigenvectors <- pca$rotation
# Calculate the percentage variance explained by each principal component
total_variance <- sum(pca$sdev^2)
pc_var_percent <- round(100 * (pca$sdev^2) / total_variance, 1)

# Convert X8.day.seascapes to a factor
filt_df_pca$X8.day.seascapes <- as.factor(filt_df_pca$X8.day.seascapes)

# # For hydrography
qq <- ggplot(filt_df_pca, aes(x = pc_scores2[,1], y = pc_scores2[,2], color = X8.day.seascapes)) +
  geom_point(size = 4) +
  scale_color_manual(values = custom_colors_pca) +
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 1], yend = eigenvectors[2, 1]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") +  # Add vector for PC1
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 2], yend = eigenvectors[2, 2]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC2
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 3], yend = eigenvectors[2, 3]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC3
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 4], yend = eigenvectors[2, 4]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC4
  geom_text(aes(x = eigenvectors[1, 1], y = eigenvectors[2, 1], 
                label = paste("PC1 (", pc_var_percent[1], "%: Salinity)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC1
  geom_text(aes(x = eigenvectors[1, 2], y = eigenvectors[2, 2], 
                label = paste("PC2 (", pc_var_percent[2], "%: Chla)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC2
  geom_text(aes(x = eigenvectors[1, 3], y = eigenvectors[2, 3], 
                label = paste("PC3 (", pc_var_percent[3], "%: PO4)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC3
  geom_text(aes(x = eigenvectors[1, 4], y = eigenvectors[2, 4], 
                label = paste("PC4 (", pc_var_percent[4], "%: NOx)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC4
  labs(x = "PC1", y = "PC2", color = "X8.day.seascapes") +
  xlim(-1.5, 1.5) +
  ylim(-1.5, 1.5) +
  guides(colour = guide_legend(override.aes = list(size=2))) + 
  theme_classic() +
  theme(axis.text.x = element_text(size = 32),  # Set X-axis label font size
        axis.text.y = element_text(size = 32)) +
  theme(axis.title.x = element_text(size = 32),
        axis.title.y = element_text(size = 32)) +
  theme(legend.text = element_text(size = 32)) 
qq


# # For phytoplankton
qq2 <- ggplot(filt_df_pca, aes(x = pc_scores2[,1], y = pc_scores2[,3], color = X8.day.seascapes)) +
  geom_point(size = 4) +
  scale_color_manual(values = custom_colors_pca) +
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 1], yend = eigenvectors[2, 1]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") +  # Add vector for PC1
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 2], yend = eigenvectors[2, 2]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC2
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 3], yend = eigenvectors[2, 3]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC3
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 4], yend = eigenvectors[2, 4]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC4
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 5], yend = eigenvectors[2, 5]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC5
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 6], yend = eigenvectors[2, 6]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC6
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 7], yend = eigenvectors[2, 7]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC7
  geom_text(aes(x = eigenvectors[1, 1], y = eigenvectors[2, 1], 
                label = paste("PC1 (", pc_var_percent[1], "%: Ceratium)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC1
  geom_text(aes(x = eigenvectors[1, 2], y = eigenvectors[2, 2], 
                label = paste("PC2 (", pc_var_percent[2], "%: Chaetoceros)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC2
  geom_text(aes(x = eigenvectors[1, 3], y = eigenvectors[2, 3], 
                label = paste("PC3 (", pc_var_percent[3], "%: Diatoms)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC3
  geom_text(aes(x = eigenvectors[1, 4], y = eigenvectors[2, 4], 
                label = paste("PC4 (", pc_var_percent[4], "%: Diatoms2)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC4
  geom_text(aes(x = eigenvectors[1, 5], y = eigenvectors[2, 5], 
                label = paste("PC5 (", pc_var_percent[5], "%: Guinardia)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC5
  geom_text(aes(x = eigenvectors[1, 6], y = eigenvectors[2, 6], 
                label = paste("PC6 (", pc_var_percent[6], "%: Neocalyptrella)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC6
  geom_text(aes(x = eigenvectors[1, 7], y = eigenvectors[2, 7], 
                label = paste("PC7 (", pc_var_percent[7], "%: Trichodesmium)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC7
  labs(x = "PC1", y = "PC3", color = "X8.day.seascapes") +
  xlim(-1, 1) +
  ylim(-1, 1) +
  guides(colour = guide_legend(override.aes = list(size=2))) + 
  theme_classic() +
  theme(axis.text.x = element_text(size = 32),  # Set X-axis label font size
        axis.text.y = element_text(size = 32)) +
  theme(axis.title.x = element_text(size = 32),
        axis.title.y = element_text(size = 32)) +
  theme(legend.text = element_text(size = 32)) 
qq2


# # For zooplankton
qq3 <- ggplot(filt_df_pca, aes(x = pc_scores2[,1], y = pc_scores2[,2], color = X8.day.seascapes)) +
  geom_point(size = 4) +
  scale_color_manual(values = custom_colors_pca) +
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 1], yend = eigenvectors[2, 1]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") +  # Add vector for PC1
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 2], yend = eigenvectors[2, 2]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC2
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 3], yend = eigenvectors[2, 3]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC3
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 4], yend = eigenvectors[2, 4]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC4
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 5], yend = eigenvectors[2, 5]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC5
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 6], yend = eigenvectors[2, 6]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC6
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 7], yend = eigenvectors[2, 7]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC7
  geom_segment(aes(x = 0, y = 0, xend = eigenvectors[1, 8], yend = eigenvectors[2, 8]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") + # Add vector for PC8
  geom_text(aes(x = eigenvectors[1, 1], y = eigenvectors[2, 1], 
                label = paste("PC1 (", pc_var_percent[1], "%: Acantharea)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC1
  geom_text(aes(x = eigenvectors[1, 2], y = eigenvectors[2, 2], 
                label = paste("PC2 (", pc_var_percent[2], "%: Copepods)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC2
  geom_text(aes(x = eigenvectors[1, 3], y = eigenvectors[2, 3], 
                label = paste("PC3 (", pc_var_percent[3], "%: Echinoderms)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC3
  geom_text(aes(x = eigenvectors[1, 4], y = eigenvectors[2, 4], 
                label = paste("PC4 (", pc_var_percent[4], "%: Jellies)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC4
  geom_text(aes(x = eigenvectors[1, 5], y = eigenvectors[2, 5], 
                label = paste("PC5 (", pc_var_percent[5], "%: Larvaceans)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC5
  geom_text(aes(x = eigenvectors[1, 6], y = eigenvectors[2, 6], 
                label = paste("PC6 (", pc_var_percent[6], "%: Polychaetes)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC6
  geom_text(aes(x = eigenvectors[1, 7], y = eigenvectors[2, 7], 
                label = paste("PC7 (", pc_var_percent[7], "%: Chaetognaths)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC7
  geom_text(aes(x = eigenvectors[1, 8], y = eigenvectors[2, 8], 
                label = paste("PC8 (", pc_var_percent[8], "%: Pteropods)", sep = "")),
            vjust = -0.5, hjust = 0.5, color = "black") +  # Add label for PC8
  labs(x = "PC1", y = "PC2", color = "X8.day.seascapes") +
  xlim(-1, 1) +
  ylim(-1, 1) +
  guides(colour = guide_legend(override.aes = list(size=2))) + 
  theme_classic() +
  theme(axis.text.x = element_text(size = 32),  # Set X-axis label font size
        axis.text.y = element_text(size = 32)) +
  theme(axis.title.x = element_text(size = 32),
        axis.title.y = element_text(size = 32)) +
  theme(legend.text = element_text(size = 32)) 
qq3

```
# Map mean values of selected taxa
```{r}
# # ggOceanMaps:
# https://biostats-r.github.io/biostats/workingInR/140_maps.html
# https://github.com/MikkoVihtakari/ggOceanMaps: Use this one: remotes::install_github("MikkoVihtakari/ggOceanMaps")
# install.packages("ggOceanMaps") # # This is outdated, don't use!!!
library(ggOceanMaps)
library(leaflet)

# For NOAA machines
# path_sfer_list <- "/Users/enrique.montes/Library/CloudStorage/GoogleDrive-enriquemontes01@gmail.com/My Drive/GDrive/proposals/2022_02_MultiStressor_NOAA/module_1"
# For personal machine
path_sfer_list <- "~/Library/CloudStorage/GoogleDrive-enriquemontes01@gmail.com/My Drive/GDrive/proposals/2022_02_MultiStressor_NOAA/module_1"

sfer_curated <- list.files(path_sfer_list, pattern = "sfer_stations_curated.csv", full.names = TRUE)

sfer_sta_list <- read.csv(sfer_curated, header = TRUE)

merged_data <- taxa_meta %>%
  left_join(sfer_sta_list %>% filter(station_class %in% "C"), by = c('Station' = 'station_id'))

# Replace 2023 and 10 with your selected year and month
selected_year <- 2023
selected_month <- 11

# Filter rows
filtered_taxa_meta <- merged_data %>%
  filter(year == selected_year, month == selected_month)

# filtered_taxa_meta <- merged_data

# Compute weighted average lat lons based on selected variable, and mean variable values (e.g., Copepods)
taxa_avg <- filtered_taxa_meta %>%
  group_by(line_id) %>%
  mutate(weight = Guinardia / sum(Guinardia, na.rm = TRUE)) %>%
  summarise(longitude = weighted.mean(dec_lon, w = weight, na.rm = TRUE),
            latitude = weighted.mean(dec_lat, w = weight, na.rm = TRUE),
            sel_taxa_mean = mean(Guinardia, na.rm = TRUE))

# # Filter out values less than 1
filtered_taxa_avg <- taxa_avg %>%
  filter(sel_taxa_mean > 0)


# Find the minimum and maximum values of sel_taxa_mean
min_value <- min(filtered_taxa_avg$sel_taxa_mean, na.rm = TRUE)
max_value <- max(filtered_taxa_avg$sel_taxa_mean, na.rm = TRUE)

# # Adjust the color palette with specified values
# color_palette <- colorNumeric(palette = "Oranges", domain = c(min_value, max_value))

# # Create the map
# map <- leaflet(filtered_taxa_avg) %>%
#   addProviderTiles("Esri.WorldImagery") %>%
#   addCircleMarkers(
#     lng = ~longitude,
#     lat = ~latitude,
#     radius = 10,
#     color = ~color_palette(sel_taxa_mean),
#     fillOpacity = 0.8,
#     popup = ~paste("Line ID: ", line_id, "<br>Copepods: ", sel_taxa_mean)
#   ) %>%
#   addLegend(
#     position = "bottomright",
#     pal = color_palette,
#     values = c(min_value, max_value),  # Adjusted values here
#     title = "Copepod occurrences",
#     opacity = 1
#   )
# map

# # Map with bathymetry
  # Overlay color-scaled dots
dt <- data.frame(
  lon = filtered_taxa_avg$longitude, 
  lat = filtered_taxa_avg$latitude, 
  sel_param = filtered_taxa_avg$sel_taxa_mean)

# # Colors:
# Acantharea = darkturquoise; breaks = c(0.25, 1, 2.5, 5); limits = c(0.1, 10)
# Copepods = red; breaks = c(0.25, 1, 2.5, 5, 10); limits = c(0.1, 15)
# Chain diatoms = orange; breaks = c(0.5, 1, 10, 30, 60); c(0.1, 70)
# Chaetoceros = purple; breaks = c(0.25, 1, 2.5, 5, 10); limits = c(0.1, 15)
# Echinoderms = magenta; breaks = c(0.5, 1, 3, 5); limits = c(0.1, 5)
# Larvaceans = plum; breaks = c(0.5, 1, 3, 5); limits = c(0.1, 5)
# Polychaetes = dodgerblue; breaks = c(0.25, 0.5, 1, 3); limits = c(0.1, 3)
# Jellies = slategray4; breaks = c(0.25, 0.5, 1, 2); limits = c(0.1, 3)
    
occ_map <- basemap(limits = c(-84, -79.5, 24, 28.5), bathymetry = TRUE) +
  geom_point(data = dt, aes(x = lon, y = lat, size = sel_param), fill = "olivedrab2", color = "olivedrab2") +
  geom_point(data = filtered_taxa_meta, aes(x = dec_lon, y = dec_lat), color = "black", shape = 3, size = 1.5) +
  scale_size_continuous(name = "Average counts", 
                        breaks = c(0.5, 1, 3, 5, 10),
                        limits = c(0.1, 40),
                        range = c(1, 15)) +
  theme_minimal() 
occ_map

# occ_map_leg <- ggplot(dt, aes(lon, lat)) +
#   geom_point(aes(size = sel_param), fill = "green", color ="green") +
#   theme_minimal()
# occ_map_leg
```

# Create time-series plots of selected taxa at specific stations
```{r}
selected_variable <- 'Chaetoceros'
# # Lower Keys
# selected_line_id <- c('LK','WS','MO','KW')
# # Middle Keys
# selected_line_id <- c('CO', 'CR')
# # Other regions
selected_line_id <- c('CAL')

# Filter the data for the selected line_id
filtered_merged_data <- merged_data[merged_data$line_id %in% selected_line_id, ]
# Remove rows with NAs in relevant columns
monthly_means <- na.omit(filtered_merged_data[, c("date", selected_variable, "line_id")]) %>%
  group_by(year_month = format(date, "%Y-%m")) %>%
  summarise(mean_value = mean(!!sym(selected_variable), na.rm = TRUE),
             se_value = sd(!!sym(selected_variable), na.rm = TRUE) / sqrt(n()))

# Create a time series plot
ggplot(monthly_means, aes(x = year_month, y = mean_value)) +
  geom_bar(stat = "identity", fill = "orange") +
  geom_errorbar(aes(ymin = mean_value - se_value, ymax = mean_value + se_value),
                width = 0.2, # Adjust width as needed
                position = position_dodge(width = 0.8)) + # Adjust width as needed
  labs(x = "Year-Month", y = "Mean Value") +
  ggtitle("Monthly Means of Selected Variable") +
  theme_minimal()

```






# Match file name with string ID - DO NOT USE
```{r}
# library(tidyverse)
# library(lubridate)
# library(dplyr)
# 
# # extract relevant part of the strings
# df <- rbind(class.Copepods,
#             class.Eucampia,
#             class.Noctiluca,
#             class.Polychaets,
#             class.Acantharea,
#             class.Centric,
#             class.Ceratium,
#             class.Chaetoceros,
#             class.Chain2,
#             class.Chain3,
#             class.Chain4,
#             class.Cladocera,
#             class.Jellies,
#             class.Larvaceans,
#             class.pellets)
# sub_strings <- substr(df$V1, start = 10, stop = 22)
# unique_all <- unique(sub_strings)
# 
# # select unique dates (this allows to search CTD records per date and time)
# # To find unique dates and times to extract CDT data use: unique_all[grepl("20221209", unique_all)]
# 
# id_list <- unique_all
# id_list2  <- as.POSIXct(id_list, format="%Y%m%d_%H%M", tz="UTC")
# 
# conc_occ_count <- data.frame(date = as.Date(character()), stringsAsFactors = FALSE)
# 
# for ( i in seq_along(id_list)){
#   acantha <- as.data.frame(str_count(class.Acantharea$V1, id_list[i]))
#   centric <- as.data.frame(str_count(class.Centric$V1, id_list[i]))
#   ceratium <- as.data.frame(str_count(class.Ceratium$V1, id_list[i]))
#   chaetoceros <- as.data.frame(str_count(class.Chaetoceros$V1, id_list[i]))
#   chaetog <- as.data.frame(str_count(class.Chaetognaths$V1, id_list[i]))
#   chain2 <- as.data.frame(str_count(class.Chain2$V1, id_list[i]))
#   chain3 <- as.data.frame(str_count(class.Chain3$V1, id_list[i]))
#   chain4 <- as.data.frame(str_count(class.Chain4$V1, id_list[i]))
#   clado <- as.data.frame(str_count(class.Cladocera$V1, id_list[i]))
#   copepods <- as.data.frame(str_count(class.Copepods$V1, id_list[i]))
#   decapod <- as.data.frame(str_count(class.Decapods$V1, id_list[i]))
#   echino <- as.data.frame(str_count(class.Echinoderms$V1, id_list[i]))
#   eucampia <- as.data.frame(str_count(class.Eucampia$V1, id_list[i]))
#   jellies <- as.data.frame(str_count(class.Jellies$V1, id_list[i]))
#   larvae <- as.data.frame(str_count(class.Larvaceans$V1, id_list[i]))
#   nocti <- as.data.frame(str_count(class.Noctiluca$V1, id_list[i]))
#   polychaetes <- as.data.frame(str_count(class.Polychaets$V1, id_list[i]))
#   tricho <- as.data.frame(str_count(class.Tricho$V1, id_list[i]))
# 
#   Acantharea <- colSums(acantha != 0)
#   Centric_diatoms <- colSums(centric != 0)
#   Ceratium_spp <- colSums(ceratium != 0)
#   Chaetoceros <- colSums(chaetoceros != 0)
#   Chaetognaths <- colSums(chaetog != 0)
#   Diatom_chains_1 <- colSums(chain2 != 0)
#   Diatom_chains_2 <- colSums(chain3 != 0)
#   Diatom_chains_3 <- colSums(chain4 != 0)
#   Cladocera <- colSums(clado != 0)
#   Copepods <- colSums(copepods != 0)
#   Decapods <- colSums(decapod != 0)
#   Echinoderms <- colSums(echino != 0)
#   Eucampia_spp <- colSums(eucampia != 0)
#   Jellies<- colSums(jellies != 0)
#   Larvaceans <- colSums(larvae != 0)
#   Noctiluca_sp <- colSums(nocti != 0)
#   Polychaetes <- colSums(polychaetes != 0)
#   Trichodesmium_spp <- colSums(tricho != 0)
# 
#   # Parse the date-time string with ymd_hm()
#   occ_datetime  <- as.POSIXct(id_list[i], format="%Y%m%d_%H%M", tz="UTC")
#   occ_datetime_str <- substr(id_list[i], 1, 13)
# 
#   row_df <- data.frame(date = occ_datetime, occ_datetime_str,
#                        Acantharea,
#                        Centric_diatoms,
#                        Ceratium_spp,
#                        Chaetoceros,
#                        Chaetognaths,
#                        Diatom_chains_1,
#                        Diatom_chains_2,
#                        Diatom_chains_3,
#                        Cladocera,
#                        Copepods,
#                        Decapods,
#                        Echinoderms,
#                        Eucampia_spp,
#                        Jellies,
#                        Larvaceans,
#                        Noctiluca_sp,
#                        Polychaetes,
#                        Trichodesmium_spp
#                        )
#   rownames(row_df) <- i
# 
#   conc_occ_count <- rbind(conc_occ_count, row_df)
# }
# 
# conc_occ_final <- arrange(conc_occ_count, date)

```


# Match image records with CTD metadata and seascapes (use with strings matching) - DO NOT USE
```{r}
# # Directory where the CTD metadata is located
# dir_path2 <- "~/enriquemontes01@gmail.com - Google Drive/My Drive/GDrive/OCED_AOML/WS_cruises/plankton_imaging/CPICS/ws_cruise_ctd/"
# file_name <- list.files(path = dir_path2, pattern = ".csv", full.names = TRUE)
# ctd_meta <- read.csv(file_name, fill = TRUE)
# 
# dt_list <- ctd_meta$GMT.datetime
# 
# conc_event <- data.frame()
# 
# for ( t in seq_along(dt_list)){
#   event <- str_count(conc_occ_final$occ_datetime_str, dt_list[t])
#   idx_event <- which(event == 1, arr.ind = TRUE)
#   occ_row <- conc_occ_final[idx_event, ]
#   event_meta <- ctd_meta[idx_event, ]
#   conc_event <- rbind(conc_event, occ_row)
# }
# 
# taxa_meta <- cbind(ctd_meta, conc_event)
```
